/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * Oasis Indexer API V1
 * An API for accessing indexed data from the Oasis Network.
 * OpenAPI spec version: 0.1.0
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  QueryFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
export type GetLayerStatsActiveAccountsWindowStepSeconds = typeof GetLayerStatsActiveAccountsWindowStepSeconds[keyof typeof GetLayerStatsActiveAccountsWindowStepSeconds];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetLayerStatsActiveAccountsWindowStepSeconds = {
  NUMBER_300: 300,
  NUMBER_86400: 86400,
} as const;

export type GetLayerStatsActiveAccountsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * The size of the step between returned statistic windows, in seconds.
The backend supports a limited number of step sizes: 300 (5 minutes) and
86400 (1 day). Requests with other values may be rejected.

 */
window_step_seconds?: GetLayerStatsActiveAccountsWindowStepSeconds;
};

export type GetLayerStatsTxVolumeParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * The size of buckets into which the statistic is grouped, in seconds.
The backend supports a limited number of bucket sizes: 300 (5 minutes) and
86400 (1 day). Requests with other values may be rejected.

 */
bucket_size_seconds?: number;
};

export type GetRuntimeEvmTokensParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetRuntimeEventsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on block round.
 */
block?: number;
/**
 * A filter on transaction index. The returned events all need to originate
from a transaction that appeared in `tx_index`-th position in the block.
It is invalid to specify this filter without also specifying a `block`.
Specifying `tx_index` and `round` is an alternative to specifying `tx_hash`;
either works to fetch events from a specific transaction.

 */
tx_index?: number;
/**
 * A filter on the hash of the transaction that originated the events.
Specifying `tx_index` and `round` is an alternative to specifying `tx_hash`;
either works to fetch events from a specific transaction.
This can be an Ethereum transaction hash; the query will compare against
both a transaction's regular tx_hash and eth_tx_hash (if it exists).

 */
tx_hash?: string;
/**
 * A filter on the event type.
 */
type?: RuntimeEventType;
/**
 * A filter on related accounts. Every returned event will refer to
this account. For example, for a `accounts.Transfer` event, this will be
the sender or the recipient of tokens.

 */
rel?: string;
/**
 * A filter on the evm log signatures.
Note: The filter will only match on parsed (verified) EVM events.

 */
evm_log_signature?: string;
};

export type GetRuntimeTransactionsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on block round.
 */
block?: number;
/**
 * A filter on minimum transaction time, inclusive.
 */
after?: string;
/**
 * A filter on maximum transaction time, exclusive.
 */
before?: string;
/**
 * A filter on related accounts. Every returned transaction will refer to
this account in a way. For example, for an `accounts.Transfer` tx, this will be
the sender or the recipient of tokens.
The indexer detects related accounts inside EVM transactions and events on a
best-effort basis. For example, it inspects ERC20 methods inside `evm.Call` txs.
However, you must provide the oasis-style derived address here, not the Eth address.
See `AddressPreimage` for more info on oasis-style vs Eth addresses.

 */
rel?: string;
};

export type GetRuntimeBlocksParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on minimum block height, inclusive.
 */
from?: number;
/**
 * A filter on maximum block height, inclusive.
 */
to?: number;
/**
 * A filter on minimum block time, inclusive.
 */
after?: string;
/**
 * A filter on maximum block time, exclusive.
 */
before?: string;
};

export type GetConsensusProposalsProposalIdVotesParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusProposalsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * The submitter of the proposal.
 */
submitter?: string;
/**
 * The state of the proposal.
 */
state?: string;
};

export type GetConsensusEpochsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusAccountsAddressDebondingDelegationsToParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusAccountsAddressDebondingDelegationsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusAccountsAddressDelegationsToParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusAccountsAddressDelegationsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusAccountsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on the minimum available account balance.
 */
minAvailable?: string;
/**
 * A filter on the maximum available account balance.
 */
maxAvailable?: string;
/**
 * A filter on the minimum active escrow account balance.
 */
minEscrow?: string;
/**
 * A filter on the maximum active escrow account balance.
 */
maxEscrow?: string;
/**
 * A filter on the minimum debonding account balance.
 */
minDebonding?: string;
/**
 * A filter on the maximum debonding account balance.
 */
maxDebonding?: string;
/**
 * A filter on the minimum total account balance.
 */
minTotalBalance?: string;
/**
 * A filter on the maximum total account balance.
 */
maxTotalBalance?: string;
};

export type GetConsensusValidatorsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusEntitiesEntityIdNodesParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusEntitiesParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
};

export type GetConsensusEventsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on block height.
 */
block?: number;
/**
 * A filter on transaction index. The returned events all need to originate
from a transaction that appeared in `tx_index`-th position in the block.
It is invalid to specify this filter without also specifying a `block`.
Specifying `tx_index` and `block` is an alternative to specifying `tx_hash`;
either works to fetch events from a specific transaction.

 */
tx_index?: number;
/**
 * A filter on the hash of the transaction that originated the events.
Specifying `tx_index` and `block` is an alternative to specifying `tx_hash`;
either works to fetch events from a specific transaction.

 */
tx_hash?: string;
/**
 * A filter on related accounts. Every returned event will refer to
this account. For example, for a `Transfer` event, this will be the
the sender or the recipient of tokens.

 */
rel?: string;
/**
 * A filter on the event type.
 */
type?: ConsensusEventType;
};

export type GetConsensusTransactionsParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on block height.
 */
block?: number;
/**
 * A filter on transaction method.
 */
method?: ConsensusTxMethod;
/**
 * A filter on transaction sender.
 */
sender?: string;
/**
 * A filter on related accounts.
 */
rel?: string;
/**
 * A filter on minimum transaction fee, inclusive.
 */
minFee?: string;
/**
 * A filter on maximum transaction fee, inclusive.
 */
maxFee?: string;
/**
 * A filter on transaction status code.
 */
code?: number;
/**
 * A filter on minimum transaction time, inclusive.
 */
after?: string;
/**
 * A filter on maximum transaction time, exclusive.
 */
before?: string;
};

export type GetConsensusBlocksParams = {
/**
 * The maximum numbers of items to return.

 */
limit?: number;
/**
 * The number of items to skip before starting to collect the result set.

 */
offset?: number;
/**
 * A filter on minimum block height, inclusive.
 */
from?: number;
/**
 * A filter on maximum block height, inclusive.
 */
to?: number;
/**
 * A filter on minimum block time, inclusive.
 */
after?: string;
/**
 * A filter on maximum block time, exclusive.
 */
before?: string;
};

/**
 * An empty response indicating that the requested resource was not found.
 */
export type NotFoundErrorResponse = unknown;

export type HumanReadableErrorResponse = {
  /** An error message. */
  msg: string;
};

export interface ActiveAccounts {
  /** The date for the end of the daily active accounts measurement window. */
  window_end: string;
  /** The number of active accounts for the 24hour window starting at bucket_start. */
  active_accounts: number;
}

/**
 * A list of daily unique active account windows.

 */
export interface ActiveAccountsList {
  window_size_seconds: number;
  /** The list of daily unique active account windows. */
  windows: ActiveAccounts[];
}

export interface TxVolume {
  /** The date for this daily transaction volume measurement. */
  bucket_start: string;
  /** The transaction volume on this day. */
  tx_volume: number;
}

/**
 * A list of daily transaction volumes.

 */
export interface TxVolumeList {
  bucket_size_seconds: number;
  /** The list of daily transaction volumes. */
  buckets: TxVolume[];
}

export interface AccountStats {
  /** The total number of tokens sent, in base units. */
  total_sent: string;
  /** The total number of tokens received, in base units. */
  total_received: string;
  /** The total number of transactions this account was involved with. */
  num_txns: number;
}

/**
 * A list of tokens in a runtime.
 */
export type EvmTokenListAllOf = {
  /** A list of L2 EVM tokens (ERC-20, ERC-271, ...). */
  evm_tokens: EvmToken[];
};

export type EvmTokenList = List & EvmTokenListAllOf;

/**
 * The type of a EVM token.

 */
export type EvmTokenType = typeof EvmTokenType[keyof typeof EvmTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EvmTokenType = {
  ERC20: 'ERC20',
} as const;

export interface EvmToken {
  /** The Oasis address of this token's contract. */
  contract_addr: string;
  /** The EVM address of this token's contract. Encoded as a lowercase hex string. */
  evm_contract_addr: string;
  /** Name of the token, as provided by token contract's `name()` method. */
  name?: string;
  /** Symbol of the token, as provided by token contract's `symbol()` method. */
  symbol?: string;
  /** The number of least significant digits in base units that should be displayed as
decimals when displaying tokens. `tokens = base_units / (10**decimals)`.
Affects display only. Often equals 18, to match ETH.
 */
  decimals?: number;
  /** The heuristically determined interface that the token contract implements.
A less specialized variant of the token might be detected; for example, an
ERC-1363 token might be labeled as ERC-20 here. If the type cannot be
detected or is not supported, this field will be null/absent.
 */
  type: EvmTokenType;
  /** The total number of base units available. */
  total_supply?: string;
  /** The number of addresses that have a nonzero balance of this token,
as calculated from Transfer events.
 */
  num_holders: number;
}

export interface RuntimeStatus {
  /** The number of compute nodes that are registered and can run the runtime. */
  active_nodes: number;
  /** The height of the most recent indexed block (also sometimes referred to as "round") for this runtime. Query a synced Oasis node for the latest block produced. */
  latest_block: number;
  /** The RFC 3339 formatted time when the Indexer processed the latest block for this runtime. Compare with current time for approximate indexing progress with the Oasis Network. */
  latest_update: string;
}

export interface RuntimeAccount {
  /** The staking address for this account. */
  address: string;
  address_preimage?: AddressPreimage;
  /** The balance(s) of this account in this runtime. Most runtimes use only one denomination, and thus
produce only one balance here. These balances do not include "layer (n+1) tokens", i.e. tokens
managed by smart contracts deployed in this runtime. For example, in EVM-compatible runtimes,
this does not include ERC-20 tokens
 */
  balances: RuntimeSdkBalance[];
  /** Data on the EVM smart contract associated with this account address. Only present for accounts
that represent a smart contract on EVM.
 */
  evm_contract?: RuntimeEvmContract;
  /** The balances of this account in each runtime, as managed by EVM smart contracts (notably, ERC-20).
NOTE: This field is limited to 1000 entries. If you need more, please let us know in a GitHub issue.
 */
  evm_balances: RuntimeEvmBalance[];
  stats: AccountStats;
}

export interface RuntimeTransactionEncryptionEnvelope {
  /** The format of the encrypted evm transaction envelope. */
  format: string;
  /** The base64-encoded public key used to encrypt the transaction. */
  public_key?: string;
  /** The base64-encoded nonce used to encrypt the transaction data. */
  data_nonce?: string;
  /** The base64-encoded encrypted transaction data. */
  data?: string;
  /** The base64-encoded nonce used to encrypt the transaction results. */
  result_nonce?: string;
  /** The base64-encoded encrypted result data. */
  result?: string;
}

/**
 * The method call body. May be null if the transaction was malformed.
 */
export type RuntimeTransactionBody = { [key: string]: any };

/**
 * A runtime transaction.

 */
export interface RuntimeTransaction {
  /** The block round at which this transaction was executed. */
  round: number;
  /** The 0-based index of this transaction in the block. */
  index: number;
  /** The second-granular consensus time when this tx's block was proposed. */
  timestamp: string;
  /** The Oasis cryptographic hash of this transaction's encoding. */
  hash: string;
  /** The Ethereum cryptographic hash of this transaction's encoding.
Absent for non-Ethereum-format transactions.
 */
  eth_hash?: string;
  /** The Oasis address of this transaction's 0th signer.
Unlike Ethereum, Oasis natively supports multiple-signature transactions.
However, the great majority of transactions only have a single signer in practice.
Retrieving the other signers is currently not supported by this API.
 */
  sender_0: string;
  /** The Ethereum address of this transaction's 0th signer.
 */
  sender_0_eth?: string;
  /** The nonce used with this transaction's 0th signer, to prevent replay. */
  nonce_0: number;
  /** The fee that this transaction's sender committed to pay to execute
it (total, native denomination, ParaTime base units, as a string).
 */
  fee: string;
  /** The maximum gas that this transaction's sender committed to use to
execute it.
 */
  gas_limit: number;
  /** The total gas used by the transaction. */
  gas_used: number;
  /** The fee that was charged for the transaction execution (total, native denomination,
ParaTime base units, as a string).
Calculated as `gas_price * gas_used`, where `gas_price = fee / gas_limit`.
 */
  charged_fee?: string;
  /** The total byte size of the transaction. */
  size: number;
  /** The method that was called. Defined by the runtime. In theory, this could be any string as the runtimes evolve.
In practice, the indexer currently expects only the following methods:
  - "accounts.Transfer"
  - "consensus.Deposit"
  - "consensus.Withdraw"
  - "evm.Create"
  - "evm.Call"
May be null if the transaction was malformed or encrypted.
 */
  method?: string;
  /** The method call body. May be null if the transaction was malformed. */
  body?: RuntimeTransactionBody;
  /** A reasonable "to" Oasis address associated with this transaction,
if applicable. The meaning varies based on the transaction method. Some notable examples:
  - For `method = "accounts.Transfer"`, this is the paratime account receiving the funds.
  - For `method = "consensus.Deposit"`, this is the paratime account receiving the funds.
  - For `method = "consensus.Withdraw"`, this is a consensus (!) account receiving the funds.
  - For `method = "evm.Create"`, this is the address of the newly created smart contract.
  - For `method = "evm.Call"`, this is the address of the called smart contract
 */
  to?: string;
  /** A reasonable "to" Ethereum address associated with this transaction,
 */
  to_eth?: string;
  /** A reasonable "amount" associated with this transaction, if
applicable. The meaning varies based on the transaction method.
Usually in native denomination, ParaTime units. As a string.
 */
  amount?: string;
  /** The data relevant to the encrypted transaction. Only present for encrypted
transactions in confidential EVM runtimes like Sapphire.
Note: The term "envelope" in this context refers to the [Oasis-style encryption envelopes](https://github.com/oasisprotocol/oasis-sdk/blob/c36a7ee194abf4ca28fdac0edbefe3843b39bf69/runtime-sdk/src/types/callformat.rs)
which differ slightly from [digital envelopes](hhttps://en.wikipedia.org/wiki/Hybrid_cryptosystem#Envelope_encryption).
 */
  encryption_envelope?: RuntimeTransactionEncryptionEnvelope;
  /** Whether this transaction successfully executed.
Can be absent (meaning "unknown") for confidential runtimes.
 */
  success?: boolean;
  /** Error details of a failed transaction. */
  error?: TxError;
}

/**
 * A list of runtime transactions.

 */
export type RuntimeTransactionListAllOf = {
  transactions: RuntimeTransaction[];
};

export type RuntimeTransactionList = List & RuntimeTransactionListAllOf;

export interface RuntimeEvmContractVerification { [key: string]: any }

export interface RuntimeEvmContract {
  /** The Oasis cryptographic hash of the transaction that created the smart contract.
 Can be omitted for contracts that were created by another contract, as opposed 
 to a direct `Create` call.
 */
  creation_tx?: string;
  /** The creation bytecode of the smart contract. This includes the constructor logic
and the constructor parameters. When run, this code generates the runtime bytecode.
Can be omitted for contracts that were created by another contract, as opposed 
to a direct `Create` call.
 */
  creation_bytecode?: string;
  /** Additional information obtained from contract verification. Only available for smart 
contracts that have been verified successfully by Sourcify.
 */
  verification?: RuntimeEvmContractVerification;
}

/**
 * A decoded parameter of an event emitted from an EVM runtime.
Values of EVM type `int128`, `uint128`, `int256`, `uint256`, `fixed`, and `ufixed` are represented as strings.
Values of EVM type `address` and `address payable` are represented as lowercase hex strings with a "0x" prefix.
Values of EVM type `bytes` and `bytes<N>` are represented as base64 strings.
Values of other EVM types (integer types, strings, arrays, etc.) are represented as their JSON counterpart.

 */
export interface EvmEventParam {
  /** The parameter name. */
  name: string;
  /** The solidity type of the event parameter. */
  evm_type: string;
  /** The parameter value. */
  value: unknown;
}

export type RuntimeEventType = typeof RuntimeEventType[keyof typeof RuntimeEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RuntimeEventType = {
  accountstransfer: 'accounts.transfer',
  accountsburn: 'accounts.burn',
  accountsmint: 'accounts.mint',
  consensus_accountsdeposit: 'consensus_accounts.deposit',
  consensus_accountswithdraw: 'consensus_accounts.withdraw',
  coregas_used: 'core.gas_used',
  evmlog: 'evm.log',
} as const;

/**
 * The decoded event contents. This spec does not encode the many possible types;
instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-sdk/client-sdk/go/modules).
This object will conform to one of the `*Event` types two levels down
the hierarchy (e.g. `MintEvent` from `accounts > Event > MintEvent`),
OR `evm > Event`.

 */
export type RuntimeEventBody = { [key: string]: any };

/**
 * An event emitted by the runtime layer
 */
export interface RuntimeEvent {
  /** The block height at which this event was generated. */
  round: number;
  /** 0-based index of this event's originating transaction within its block.
Absent if the event did not originate from a transaction.
 */
  tx_index?: number;
  /** Hash of this event's originating transaction.
Absent if the event did not originate from a transaction.
 */
  tx_hash?: string | null;
  /** Ethereum trasnsaction hash of this event's originating transaction.
Absent if the event did not originate from an EVM transaction.
 */
  eth_tx_hash?: string;
  /** The type of the event. */
  type: RuntimeEventType;
  /** The decoded event contents. This spec does not encode the many possible types;
instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-sdk/client-sdk/go/modules).
This object will conform to one of the `*Event` types two levels down
the hierarchy (e.g. `MintEvent` from `accounts > Event > MintEvent`),
OR `evm > Event`.
 */
  body: RuntimeEventBody;
  /** If the event type is `evm.log`, this field describes the human-readable type of evm event, e.g.
`Transfer`. We currently only support two types of evm events, ERC20 `Transfer` and `Approve`.
Absent if the event type is not `evm.log`.
 */
  evm_log_name?: string | null;
  /** The decoded `evm.log` event data. We currently support only two types of evm events, ERC20 `Transfer`
and `Approve`.
Absent if the event type is not `evm.log`.
 */
  evm_log_params?: EvmEventParam[];
}

/**
 * A list of runtime events.

 */
export type RuntimeEventListAllOf = {
  events: RuntimeEvent[];
};

export type RuntimeEventList = List & RuntimeEventListAllOf;

/**
 * A ParaTime block.

 */
export interface RuntimeBlock {
  /** The block round. */
  round: number;
  /** The block header hash. */
  hash: string;
  /** The second-granular consensus time. */
  timestamp: string;
  /** The number of transactions in the block. */
  num_transactions: number;
  /** The total byte size of all transactions in the block. */
  size: number;
  /** The total gas used by all transactions in the block. */
  gas_used: number;
}

/**
 * A list of consensus blocks.

 */
export type RuntimeBlockListAllOf = {
  blocks: RuntimeBlock[];
};

export type RuntimeBlockList = List & RuntimeBlockListAllOf;

export interface ProposalVote {
  /** The staking address casting this vote. */
  address: string;
  /** The vote cast. */
  vote: string;
}

/**
 * A list of votes for a governance proposal.

 */
export type ProposalVotesAllOf = {
  /** The unique identifier of the proposal. */
  proposal_id: number;
  /** The list of votes for the proposal. */
  votes: ProposalVote[];
};

export type ProposalVotes = List & ProposalVotesAllOf;

/**
 * The target propotocol versions for this upgrade proposal.
 */
export interface ProposalTarget {
  consensus_protocol?: string;
  runtime_host_protocol?: string;
  runtime_committee_protocol?: string;
}

/**
 * A governance proposal.

 */
export interface Proposal {
  /** The unique identifier of the proposal. */
  id: number;
  /** The staking address of the proposal submitter. */
  submitter: string;
  /** The state of the proposal. */
  state: string;
  /** The deposit attached to this proposal. */
  deposit: string;
  /** The name of the upgrade handler. */
  handler?: string;
  target?: ProposalTarget;
  /** The epoch at which the proposed upgrade will happen. */
  epoch?: number;
  /** The proposal to cancel, if this proposal proposes
cancelling an existing proposal.
 */
  cancels?: number;
  /** The epoch at which this proposal was created. */
  created_at: number;
  /** The epoch at which voting for this proposal will close. */
  closes_at: number;
  /** The number of invalid votes for this proposal, after tallying.
 */
  invalid_votes: string;
}

/**
 * A list of governance proposals.

 */
export type ProposalListAllOf = {
  proposals: Proposal[];
};

export type ProposalList = List & ProposalListAllOf;

/**
 * A consensus epoch.

 */
export interface Epoch {
  /** The epoch number. */
  id: number;
  /** The (inclusive) height at which this epoch started. */
  start_height: number;
  /** The (inclusive) height at which this epoch ended. Omitted if the epoch is still active. */
  end_height?: number;
}

/**
 * A list of consensus epochs.

 */
export type EpochListAllOf = {
  epochs: Epoch[];
};

export type EpochList = List & EpochListAllOf;

export interface Allowance {
  /** The allowed account. */
  address: string;
  /** The amount allowed for the allowed account. */
  amount: string;
}

/**
 * A consensus layer account.

 */
export interface Account {
  /** The staking address for this account. */
  address: string;
  /** A nonce used to prevent replay. */
  nonce: number;
  /** The available balance, in base units. */
  available: string;
  /** The active escrow balance, in base units. */
  escrow: string;
  /** The debonding escrow balance, in base units. */
  debonding: string;
  /** The delegations balance, in base units.
For efficiency, this field is omitted when listing multiple-accounts.
 */
  delegations_balance?: string;
  /** The debonding delegations balance, in base units.
For efficiency, this field is omitted when listing multiple-accounts.
 */
  debonding_delegations_balance?: string;
  /** The allowances made by this account. */
  allowances: Allowance[];
}

/**
 * Balance of an account for a specific runtime and EVM token.
 */
export interface RuntimeEvmBalance {
  /** Number of tokens held, in base units. */
  balance: string;
  /** The EVM address of this token's contract. Encoded as a lowercase hex string. */
  token_contract_addr: string;
  /** The token ticker symbol. Not guaranteed to be unique across distinct EVM tokens. */
  token_symbol?: string;
  /** The name of the token. Not guaranteed to be unique across distinct EVM tokens. */
  token_name?: string;
  token_type: EvmTokenType;
  /** The number of decimals of precision for this token. */
  token_decimals: number;
}

/**
 * Balance of an account for a specific runtime and oasis-sdk token (e.g. ROSE).
 */
export interface RuntimeSdkBalance {
  /** Number of tokens held, in base units. */
  balance: string;
  /** The token ticker symbol. Unique across all oasis-sdk tokens in the same runtime. */
  token_symbol: string;
  /** The number of decimals of precision for this token. */
  token_decimals: number;
}

export type AddressDerivationContext = typeof AddressDerivationContext[keyof typeof AddressDerivationContext];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AddressDerivationContext = {
  'oasis-core/address:_staking': 'oasis-core/address: staking',
  'oasis-runtime-sdk/address:_secp256k1eth': 'oasis-runtime-sdk/address: secp256k1eth',
  'oasis-runtime-sdk/address:_sr25519': 'oasis-runtime-sdk/address: sr25519',
  'oasis-runtime-sdk/address:_multisig': 'oasis-runtime-sdk/address: multisig',
  'oasis-runtime-sdk/address:_module': 'oasis-runtime-sdk/address: module',
  'oasis-runtime-sdk/address:_runtime': 'oasis-runtime-sdk/address: runtime',
} as const;

/**
 * The data from which a consensus-style address (`oasis1...`)
was derived. Notably, for EVM runtimes like Sapphire,
this links the oasis address and the Ethereum address.

Oasis addresses are derived from a piece of data, such as an ed25519
public key or an Ethereum address. For example, [this](https://github.com/oasisprotocol/oasis-sdk/blob/b37e6da699df331f5a2ac62793f8be099c68469c/client-sdk/go/helpers/address.go#L90-L91)
is how an Ethereum is converted to an oasis address. The type of underlying data usually also
determines how the signatuers for this address are verified.

Consensus supports only "staking addresses" (`context="oasis-core/address: staking"`
below; always ed25519-backed).
Runtimes support all types. This means that every consensus address is also
valid in every runtime. For example, in EVM runtimes, you can use staking
addresses, but only with oasis tools (e.g. a wallet); EVM contracts such as
ERC20 tokens or tools such as Metamask cannot interact with staking addresses.

 */
export interface AddressPreimage {
  /** The method by which the oasis address was derived from `address_data`.
 */
  context: AddressDerivationContext;
  /** Version of the `context`. */
  context_version?: number | null;
  /** The base64-encoded data from which the oasis address was derived.
When `context = "oasis-runtime-sdk/address: secp256k1eth"`, this
is the Ethereum address (in base64, not hex!).
 */
  address_data: string;
}

/**
 * A list of consensus layer accounts.

 */
export type AccountListAllOf = {
  accounts: Account[];
};

export type AccountList = List & AccountListAllOf;

/**
 * A node registered at the consensus layer.

 */
export interface Node {
  /** The public key identifying this node. */
  id: string;
  /** The public key identifying the entity controlling this node.
 */
  entity_id: string;
  /** The epoch in which this node's commitment expires. */
  expiration: number;
  /** The public key used for establishing TLS connections. */
  tls_pubkey: string;
  /** The public key that will be used for establishing TLS connections
upon rotation.
 */
  tls_next_pubkey: string;
  /** The unique identifier of this node on the P2P transport. */
  p2p_pubkey: string;
  /** The unique identifier of this node as a consensus member */
  consensus_pubkey: string;
  /** A bitmask representing this node's roles. */
  roles: string;
}

/**
 * A list of nodes registered at the consensus layer.

 */
export type NodeListAllOf = {
  entity_id: string;
  nodes: Node[];
};

export type NodeList = List & NodeListAllOf;

export interface ValidatorMedia {
  /** An URL associated with the entity. */
  website_link?: string;
  /** An email address for the validator. */
  email_address?: string;
  /** A Twitter handle. */
  twitter_acc?: string;
  /** An Telegram handle. */
  tg_chat?: string;
  /** A logo type. */
  logotype?: string;
  /** The human-readable name of this validator. */
  name?: string;
}

export interface ValidatorCommissionBound {
  lower: number;
  upper: number;
  epoch_start: number;
  epoch_end: number;
}

/**
 * An validator registered at the consensus layer.

 */
export interface Validator {
  /** The staking address identifying this Validator. */
  entity_address: string;
  /** The public key identifying this Validator. */
  entity_id: string;
  /** The public key identifying this Validator's node. */
  node_id: string;
  /** The amount staked. */
  escrow: string;
  /** Whether the entity is part of validator set (top <scheduler.params.max_validators> by stake). */
  active: boolean;
  /** Whether the entity has a node that is registered for being a validator, node is up to date, and has successfully registered itself. It may or may not be part of validator set. */
  status: boolean;
  media?: ValidatorMedia;
  /** Commission rate. */
  current_rate: number;
  current_commission_bound: ValidatorCommissionBound;
}

/**
 * A list of validators registered at the consensus layer.

 */
export type ValidatorListAllOf = {
  validators: Validator[];
};

export type ValidatorList = List & ValidatorListAllOf;

/**
 * An entity registered at the consensus layer.

 */
export interface Entity {
  /** The public key identifying this entity. */
  id: string;
  /** The staking address belonging to this entity; derived from the entity's public key. */
  address: string;
  /** The vector of nodes owned by this entity. */
  nodes: string[];
}

/**
 * A list of entities registered at the consensus layer.

 */
export type EntityListAllOf = {
  entities: Entity[];
};

export type EntityList = List & EntityListAllOf;

/**
 * The event contents. This spec does not encode the many possible types;
instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/consensus/api/transaction/results#Event) of oasis-core.
This object will conform to one of the `*Event` types two levels down
the hierarchy, e.g. `TransferEvent` from `Event > staking.Event > TransferEvent`

 */
export type ConsensusEventBody = { [key: string]: any };

/**
 * An event emitted by the consensus layer.

 */
export interface ConsensusEvent {
  /** The block height at which this event was generated. */
  block: number;
  /** 0-based index of this event's originating transaction within its block.
Absent if the event did not originate from a transaction.
 */
  tx_index?: number | null;
  /** Hash of this event's originating transaction.
Absent if the event did not originate from a transaction.
 */
  tx_hash?: string | null;
  /** The type of the event. */
  type: ConsensusEventType;
  /** The event contents. This spec does not encode the many possible types;
instead, see [the Go API](https://pkg.go.dev/github.com/oasisprotocol/oasis-core/go/consensus/api/transaction/results#Event) of oasis-core.
This object will conform to one of the `*Event` types two levels down
the hierarchy, e.g. `TransferEvent` from `Event > staking.Event > TransferEvent`
 */
  body: ConsensusEventBody;
}

/**
 * A list of consensus events.

 */
export type ConsensusEventListAllOf = {
  events: ConsensusEvent[];
};

export type ConsensusEventList = List & ConsensusEventListAllOf;

export type ConsensusEventType = typeof ConsensusEventType[keyof typeof ConsensusEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConsensusEventType = {
  governanceproposal_executed: 'governance.proposal_executed',
  governanceproposal_finalized: 'governance.proposal_finalized',
  governanceproposal_submitted: 'governance.proposal_submitted',
  governancevote: 'governance.vote',
  registryentity: 'registry.entity',
  registrynode_unfrozen: 'registry.node_unfrozen',
  registrynode: 'registry.node',
  registryruntime: 'registry.runtime',
  roothashexecution_discrepancy: 'roothash.execution_discrepancy',
  roothashexecutor_committed: 'roothash.executor_committed',
  roothashfinalized: 'roothash.finalized',
  stakingallowance_change: 'staking.allowance_change',
  stakingburn: 'staking.burn',
  stakingescrowadd: 'staking.escrow.add',
  stakingescrowdebonding_start: 'staking.escrow.debonding_start',
  stakingescrowreclaim: 'staking.escrow.reclaim',
  stakingescrowtake: 'staking.escrow.take',
  stakingtransfer: 'staking.transfer',
} as const;

export interface TxError {
  /** The module of a failed transaction. */
  module?: string;
  /** The status code of a failed transaction. */
  code: number;
  /** The message of a failed transaction. */
  message?: string;
}

/**
 * A list of consensus transactions.

 */
export type TransactionListAllOf = {
  transactions: Transaction[];
};

export type TransactionList = List & TransactionListAllOf;

export type ConsensusTxMethod = typeof ConsensusTxMethod[keyof typeof ConsensusTxMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConsensusTxMethod = {
  stakingTransfer: 'staking.Transfer',
  stakingAddEscrow: 'staking.AddEscrow',
  stakingReclaimEscrow: 'staking.ReclaimEscrow',
  stakingAmendCommissionSchedule: 'staking.AmendCommissionSchedule',
  stakingAllow: 'staking.Allow',
  stakingWithdraw: 'staking.Withdraw',
  roothashExecutorCommit: 'roothash.ExecutorCommit',
  roothashExecutorProposerTimeout: 'roothash.ExecutorProposerTimeout',
  registryRegisterEntity: 'registry.RegisterEntity',
  registryRegisterNode: 'registry.RegisterNode',
  registryRegisterRuntime: 'registry.RegisterRuntime',
  governanceCastVote: 'governance.CastVote',
  governanceSubmitProposal: 'governance.SubmitProposal',
  beaconPVSSCommit: 'beacon.PVSSCommit',
  beaconPVSSReveal: 'beacon.PVSSReveal',
  beaconVRFProve: 'beacon.VRFProve',
} as const;

/**
 * A consensus transaction.

 */
export interface Transaction {
  /** The block height at which this transaction was executed. */
  block: number;
  /** 0-based index of this transaction in its block */
  index: number;
  /** The second-granular consensus time this tx's block, i.e. roughly when the
[block was proposed](https://github.com/tendermint/tendermint/blob/v0.34.x/spec/core/data_structures.md#header).
 */
  timestamp: string;
  /** The cryptographic hash of this transaction's encoding. */
  hash: string;
  /** The address of who sent this transaction. */
  sender: string;
  /** The nonce used with this transaction, to prevent replay. */
  nonce: number;
  /** The fee that this transaction's sender committed
to pay to execute it.
 */
  fee: string;
  /** The method that was called. */
  method: ConsensusTxMethod;
  /** The method call body. */
  body: string;
  /** Whether this transaction successfully executed. */
  success: boolean;
  /** Error details of a failed transaction. */
  error?: TxError;
}

/**
 * A debonding delegation.

 */
export interface DebondingDelegation {
  /** The amount of tokens delegated in base units. */
  amount: string;
  /** The shares of tokens delegated. */
  shares: string;
  /** The delegatee (validator) address. */
  validator: string;
  /** The delegator address. */
  delegator: string;
  /** The epoch at which the debonding ends. */
  debond_end: number;
}

/**
 * A list of debonding delegations.

 */
export type DebondingDelegationListAllOf = {
  debonding_delegations: DebondingDelegation[];
};

export type DebondingDelegationList = List & DebondingDelegationListAllOf;

/**
 * A delegation.

 */
export interface Delegation {
  /** The amount of tokens delegated in base units. */
  amount: string;
  /** The shares of tokens delegated. */
  shares: string;
  /** The delegatee (validator) address. */
  validator: string;
  /** The delegator address. */
  delegator: string;
}

/**
 * A list of delegations.

 */
export type DelegationListAllOf = {
  delegations: Delegation[];
};

export type DelegationList = List & DelegationListAllOf;

/**
 * A consensus block.

 */
export interface Block {
  /** The block height. */
  height: number;
  /** The block header hash. */
  hash: string;
  /** The second-granular consensus time. */
  timestamp: string;
  /** Number of transactions in the block. */
  num_transactions: number;
}

export type BlockListAllOf = {
  blocks: Block[];
};

export interface Status {
  /** The height of the most recent indexed block. Query a synced Oasis node for the latest block produced. */
  latest_block: number;
  /** The RFC 3339 formatted time when the Indexer processed the latest block. Compare with current time for approximate indexing progress with the Oasis Network. */
  latest_update: string;
}

export interface List {
  /** The total number of records that match the query, i.e. the number of records
the query would return with limit=infinity.
 */
  total_count: number;
  /** Whether total_count is clipped for performance reasons. */
  is_total_count_clipped: boolean;
}

/**
 * A list of consensus blocks.

 */
export type BlockList = List & BlockListAllOf;

export type Runtime = typeof Runtime[keyof typeof Runtime];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Runtime = {
  emerald: 'emerald',
  sapphire: 'sapphire',
  cipher: 'cipher',
} as const;

export type Layer = typeof Layer[keyof typeof Layer];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Layer = {
  emerald: 'emerald',
  sapphire: 'sapphire',
  cipher: 'cipher',
  consensus: 'consensus',
} as const;



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


/**
 * @summary Returns the indexer status.
 */
export const getStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Status>> => {
    return axios.get(
      `/`,options
    );
  }


export const getGetStatusQueryKey = () => [`/`] as const;
  

    
export const getGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof getStatus>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatusQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatus>>> = ({ signal }) => getStatus({ signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getStatus>>>
export type GetStatusQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns the indexer status.
 */
export const useGetStatus = <TData = Awaited<ReturnType<typeof getStatus>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetStatusQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of consensus blocks, sorted from most to least recent.
 */
export const getConsensusBlocks = (
    params?: GetConsensusBlocksParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BlockList>> => {
    return axios.get(
      `/consensus/blocks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusBlocksQueryKey = (params?: GetConsensusBlocksParams,) => [`/consensus/blocks`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusBlocksQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusBlocks>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocks>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocks>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusBlocksQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusBlocks>>> = ({ signal }) => getConsensusBlocks(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusBlocksQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusBlocks>>>
export type GetConsensusBlocksQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of consensus blocks, sorted from most to least recent.
 */
export const useGetConsensusBlocks = <TData = Awaited<ReturnType<typeof getConsensusBlocks>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocks>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusBlocksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a consensus block.
 */
export const getConsensusBlocksHeight = (
    height: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Block>> => {
    return axios.get(
      `/consensus/blocks/${height}`,options
    );
  }


export const getGetConsensusBlocksHeightQueryKey = (height: number,) => [`/consensus/blocks/${height}`] as const;
  

    
export const getGetConsensusBlocksHeightQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(height: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusBlocksHeightQueryKey(height);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusBlocksHeight>>> = ({ signal }) => getConsensusBlocksHeight(height, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(height), ...queryOptions}}

export type GetConsensusBlocksHeightQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusBlocksHeight>>>
export type GetConsensusBlocksHeightQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a consensus block.
 */
export const useGetConsensusBlocksHeight = <TData = Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 height: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusBlocksHeightQueryOptions(height,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of consensus transactions.
 */
export const getConsensusTransactions = (
    params?: GetConsensusTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionList>> => {
    return axios.get(
      `/consensus/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusTransactionsQueryKey = (params?: GetConsensusTransactionsParams,) => [`/consensus/transactions`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusTransactions>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactions>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusTransactionsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusTransactions>>> = ({ signal }) => getConsensusTransactions(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusTransactions>>>
export type GetConsensusTransactionsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of consensus transactions.
 */
export const useGetConsensusTransactions = <TData = Awaited<ReturnType<typeof getConsensusTransactions>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactions>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a consensus transaction.
 */
export const getConsensusTransactionsTxHash = (
    txHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Transaction>> => {
    return axios.get(
      `/consensus/transactions/${txHash}`,options
    );
  }


export const getGetConsensusTransactionsTxHashQueryKey = (txHash: string,) => [`/consensus/transactions/${txHash}`] as const;
  

    
export const getGetConsensusTransactionsTxHashQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(txHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusTransactionsTxHashQueryKey(txHash);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>> = ({ signal }) => getConsensusTransactionsTxHash(txHash, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(txHash), ...queryOptions}}

export type GetConsensusTransactionsTxHashQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>>
export type GetConsensusTransactionsTxHashQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a consensus transaction.
 */
export const useGetConsensusTransactionsTxHash = <TData = Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 txHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusTransactionsTxHashQueryOptions(txHash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of consensus events.
 */
export const getConsensusEvents = (
    params?: GetConsensusEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ConsensusEventList>> => {
    return axios.get(
      `/consensus/events`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEventsQueryKey = (params?: GetConsensusEventsParams,) => [`/consensus/events`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusEventsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEvents>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEvents>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEvents>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEventsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEvents>>> = ({ signal }) => getConsensusEvents(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEvents>>>
export type GetConsensusEventsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of consensus events.
 */
export const useGetConsensusEvents = <TData = Awaited<ReturnType<typeof getConsensusEvents>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEvents>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEventsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of entities registered at the consensus layer.
 */
export const getConsensusEntities = (
    params?: GetConsensusEntitiesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EntityList>> => {
    return axios.get(
      `/consensus/entities`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEntitiesQueryKey = (params?: GetConsensusEntitiesParams,) => [`/consensus/entities`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusEntitiesQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEntities>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusEntitiesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntities>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntities>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEntitiesQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntities>>> = ({ signal }) => getConsensusEntities(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusEntitiesQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntities>>>
export type GetConsensusEntitiesQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of entities registered at the consensus layer.
 */
export const useGetConsensusEntities = <TData = Awaited<ReturnType<typeof getConsensusEntities>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusEntitiesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntities>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEntitiesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns an entity registered at the consensus layer.
 */
export const getConsensusEntitiesEntityId = (
    entityId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Entity>> => {
    return axios.get(
      `/consensus/entities/${entityId}`,options
    );
  }


export const getGetConsensusEntitiesEntityIdQueryKey = (entityId: string,) => [`/consensus/entities/${entityId}`] as const;
  

    
export const getGetConsensusEntitiesEntityIdQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(entityId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEntitiesEntityIdQueryKey(entityId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>> = ({ signal }) => getConsensusEntitiesEntityId(entityId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(entityId), ...queryOptions}}

export type GetConsensusEntitiesEntityIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>>
export type GetConsensusEntitiesEntityIdQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns an entity registered at the consensus layer.
 */
export const useGetConsensusEntitiesEntityId = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 entityId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEntitiesEntityIdQueryOptions(entityId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of nodes registered at the consensus layer.
 */
export const getConsensusEntitiesEntityIdNodes = (
    entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NodeList>> => {
    return axios.get(
      `/consensus/entities/${entityId}/nodes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEntitiesEntityIdNodesQueryKey = (entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams,) => [`/consensus/entities/${entityId}/nodes`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusEntitiesEntityIdNodesQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEntitiesEntityIdNodesQueryKey(entityId,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>> = ({ signal }) => getConsensusEntitiesEntityIdNodes(entityId,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(entityId), ...queryOptions}}

export type GetConsensusEntitiesEntityIdNodesQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>>
export type GetConsensusEntitiesEntityIdNodesQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of nodes registered at the consensus layer.
 */
export const useGetConsensusEntitiesEntityIdNodes = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEntitiesEntityIdNodesQueryOptions(entityId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a node registered at the consensus layer.
 */
export const getConsensusEntitiesEntityIdNodesNodeId = (
    entityId: string,
    nodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Node>> => {
    return axios.get(
      `/consensus/entities/${entityId}/nodes/${nodeId}`,options
    );
  }


export const getGetConsensusEntitiesEntityIdNodesNodeIdQueryKey = (entityId: string,
    nodeId: string,) => [`/consensus/entities/${entityId}/nodes/${nodeId}`] as const;
  

    
export const getGetConsensusEntitiesEntityIdNodesNodeIdQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(entityId: string,
    nodeId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEntitiesEntityIdNodesNodeIdQueryKey(entityId,nodeId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>> = ({ signal }) => getConsensusEntitiesEntityIdNodesNodeId(entityId,nodeId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(entityId && nodeId), ...queryOptions}}

export type GetConsensusEntitiesEntityIdNodesNodeIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>>
export type GetConsensusEntitiesEntityIdNodesNodeIdQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a node registered at the consensus layer.
 */
export const useGetConsensusEntitiesEntityIdNodesNodeId = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 entityId: string,
    nodeId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEntitiesEntityIdNodesNodeIdQueryOptions(entityId,nodeId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of validators registered at the consensus layer.
 */
export const getConsensusValidators = (
    params?: GetConsensusValidatorsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ValidatorList>> => {
    return axios.get(
      `/consensus/validators`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusValidatorsQueryKey = (params?: GetConsensusValidatorsParams,) => [`/consensus/validators`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusValidatorsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusValidators>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusValidatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidators>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidators>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusValidatorsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusValidators>>> = ({ signal }) => getConsensusValidators(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusValidatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusValidators>>>
export type GetConsensusValidatorsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of validators registered at the consensus layer.
 */
export const useGetConsensusValidators = <TData = Awaited<ReturnType<typeof getConsensusValidators>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusValidatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidators>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusValidatorsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a validator registered at the consensus layer.
 */
export const getConsensusValidatorsEntityId = (
    entityId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Validator>> => {
    return axios.get(
      `/consensus/validators/${entityId}`,options
    );
  }


export const getGetConsensusValidatorsEntityIdQueryKey = (entityId: string,) => [`/consensus/validators/${entityId}`] as const;
  

    
export const getGetConsensusValidatorsEntityIdQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(entityId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusValidatorsEntityIdQueryKey(entityId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>> = ({ signal }) => getConsensusValidatorsEntityId(entityId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(entityId), ...queryOptions}}

export type GetConsensusValidatorsEntityIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>>
export type GetConsensusValidatorsEntityIdQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a validator registered at the consensus layer.
 */
export const useGetConsensusValidatorsEntityId = <TData = Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 entityId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusValidatorsEntityIdQueryOptions(entityId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of consensus layer accounts.
 */
export const getConsensusAccounts = (
    params?: GetConsensusAccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountList>> => {
    return axios.get(
      `/consensus/accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusAccountsQueryKey = (params?: GetConsensusAccountsParams,) => [`/consensus/accounts`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusAccountsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusAccounts>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccounts>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccounts>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusAccountsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccounts>>> = ({ signal }) => getConsensusAccounts(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccounts>>>
export type GetConsensusAccountsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of consensus layer accounts.
 */
export const useGetConsensusAccounts = <TData = Awaited<ReturnType<typeof getConsensusAccounts>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccounts>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusAccountsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a consensus layer account.
 */
export const getConsensusAccountsAddress = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account>> => {
    return axios.get(
      `/consensus/accounts/${address}`,options
    );
  }


export const getGetConsensusAccountsAddressQueryKey = (address: string,) => [`/consensus/accounts/${address}`] as const;
  

    
export const getGetConsensusAccountsAddressQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusAccountsAddressQueryKey(address);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddress>>> = ({ signal }) => getConsensusAccountsAddress(address, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions}}

export type GetConsensusAccountsAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddress>>>
export type GetConsensusAccountsAddressQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a consensus layer account.
 */
export const useGetConsensusAccountsAddress = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusAccountsAddressQueryOptions(address,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns an account's delegations.
 */
export const getConsensusAccountsAddressDelegations = (
    address: string,
    params?: GetConsensusAccountsAddressDelegationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DelegationList>> => {
    return axios.get(
      `/consensus/accounts/${address}/delegations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusAccountsAddressDelegationsQueryKey = (address: string,
    params?: GetConsensusAccountsAddressDelegationsParams,) => [`/consensus/accounts/${address}/delegations`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusAccountsAddressDelegationsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(address: string,
    params?: GetConsensusAccountsAddressDelegationsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusAccountsAddressDelegationsQueryKey(address,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>> = ({ signal }) => getConsensusAccountsAddressDelegations(address,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions}}

export type GetConsensusAccountsAddressDelegationsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>>
export type GetConsensusAccountsAddressDelegationsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns an account's delegations.
 */
export const useGetConsensusAccountsAddressDelegations = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 address: string,
    params?: GetConsensusAccountsAddressDelegationsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusAccountsAddressDelegationsQueryOptions(address,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of delegations to an account.
 */
export const getConsensusAccountsAddressDelegationsTo = (
    address: string,
    params?: GetConsensusAccountsAddressDelegationsToParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DelegationList>> => {
    return axios.get(
      `/consensus/accounts/${address}/delegations_to`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusAccountsAddressDelegationsToQueryKey = (address: string,
    params?: GetConsensusAccountsAddressDelegationsToParams,) => [`/consensus/accounts/${address}/delegations_to`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusAccountsAddressDelegationsToQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(address: string,
    params?: GetConsensusAccountsAddressDelegationsToParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusAccountsAddressDelegationsToQueryKey(address,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>> = ({ signal }) => getConsensusAccountsAddressDelegationsTo(address,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions}}

export type GetConsensusAccountsAddressDelegationsToQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>>
export type GetConsensusAccountsAddressDelegationsToQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of delegations to an account.
 */
export const useGetConsensusAccountsAddressDelegationsTo = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 address: string,
    params?: GetConsensusAccountsAddressDelegationsToParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegationsTo>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusAccountsAddressDelegationsToQueryOptions(address,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns an account's debonding delegations.
 */
export const getConsensusAccountsAddressDebondingDelegations = (
    address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DebondingDelegationList>> => {
    return axios.get(
      `/consensus/accounts/${address}/debonding_delegations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusAccountsAddressDebondingDelegationsQueryKey = (address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsParams,) => [`/consensus/accounts/${address}/debonding_delegations`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusAccountsAddressDebondingDelegationsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusAccountsAddressDebondingDelegationsQueryKey(address,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>> = ({ signal }) => getConsensusAccountsAddressDebondingDelegations(address,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions}}

export type GetConsensusAccountsAddressDebondingDelegationsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>>
export type GetConsensusAccountsAddressDebondingDelegationsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns an account's debonding delegations.
 */
export const useGetConsensusAccountsAddressDebondingDelegations = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusAccountsAddressDebondingDelegationsQueryOptions(address,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of debonding delegations to an account.
 */
export const getConsensusAccountsAddressDebondingDelegationsTo = (
    address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsToParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DebondingDelegationList>> => {
    return axios.get(
      `/consensus/accounts/${address}/debonding_delegations_to`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusAccountsAddressDebondingDelegationsToQueryKey = (address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsToParams,) => [`/consensus/accounts/${address}/debonding_delegations_to`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusAccountsAddressDebondingDelegationsToQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsToParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusAccountsAddressDebondingDelegationsToQueryKey(address,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>> = ({ signal }) => getConsensusAccountsAddressDebondingDelegationsTo(address,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions}}

export type GetConsensusAccountsAddressDebondingDelegationsToQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>>
export type GetConsensusAccountsAddressDebondingDelegationsToQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of debonding delegations to an account.
 */
export const useGetConsensusAccountsAddressDebondingDelegationsTo = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 address: string,
    params?: GetConsensusAccountsAddressDebondingDelegationsToParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegationsTo>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusAccountsAddressDebondingDelegationsToQueryOptions(address,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of consensus epochs.
 */
export const getConsensusEpochs = (
    params?: GetConsensusEpochsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EpochList>> => {
    return axios.get(
      `/consensus/epochs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEpochsQueryKey = (params?: GetConsensusEpochsParams,) => [`/consensus/epochs`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusEpochsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEpochs>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusEpochsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochs>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochs>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEpochsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEpochs>>> = ({ signal }) => getConsensusEpochs(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusEpochsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEpochs>>>
export type GetConsensusEpochsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of consensus epochs.
 */
export const useGetConsensusEpochs = <TData = Awaited<ReturnType<typeof getConsensusEpochs>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusEpochsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochs>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEpochsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a consensus epoch.
 */
export const getConsensusEpochsEpoch = (
    epoch: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Epoch>> => {
    return axios.get(
      `/consensus/epochs/${epoch}`,options
    );
  }


export const getGetConsensusEpochsEpochQueryKey = (epoch: number,) => [`/consensus/epochs/${epoch}`] as const;
  

    
export const getGetConsensusEpochsEpochQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(epoch: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusEpochsEpochQueryKey(epoch);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>> = ({ signal }) => getConsensusEpochsEpoch(epoch, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(epoch), ...queryOptions}}

export type GetConsensusEpochsEpochQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>>
export type GetConsensusEpochsEpochQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a consensus epoch.
 */
export const useGetConsensusEpochsEpoch = <TData = Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 epoch: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusEpochsEpochQueryOptions(epoch,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of governance proposals.
 */
export const getConsensusProposals = (
    params?: GetConsensusProposalsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProposalList>> => {
    return axios.get(
      `/consensus/proposals`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusProposalsQueryKey = (params?: GetConsensusProposalsParams,) => [`/consensus/proposals`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusProposalsQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusProposals>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(params?: GetConsensusProposalsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposals>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposals>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusProposalsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusProposals>>> = ({ signal }) => getConsensusProposals(params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GetConsensusProposalsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusProposals>>>
export type GetConsensusProposalsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of governance proposals.
 */
export const useGetConsensusProposals = <TData = Awaited<ReturnType<typeof getConsensusProposals>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 params?: GetConsensusProposalsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposals>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusProposalsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a governance proposal.
 */
export const getConsensusProposalsProposalId = (
    proposalId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Proposal>> => {
    return axios.get(
      `/consensus/proposals/${proposalId}`,options
    );
  }


export const getGetConsensusProposalsProposalIdQueryKey = (proposalId: number,) => [`/consensus/proposals/${proposalId}`] as const;
  

    
export const getGetConsensusProposalsProposalIdQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(proposalId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusProposalsProposalIdQueryKey(proposalId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>> = ({ signal }) => getConsensusProposalsProposalId(proposalId, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(proposalId), ...queryOptions}}

export type GetConsensusProposalsProposalIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>>
export type GetConsensusProposalsProposalIdQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a governance proposal.
 */
export const useGetConsensusProposalsProposalId = <TData = Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 proposalId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusProposalsProposalIdQueryOptions(proposalId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of votes for a governance proposal.
 */
export const getConsensusProposalsProposalIdVotes = (
    proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProposalVotes>> => {
    return axios.get(
      `/consensus/proposals/${proposalId}/votes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusProposalsProposalIdVotesQueryKey = (proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams,) => [`/consensus/proposals/${proposalId}/votes`, ...(params ? [params]: [])] as const;
  

    
export const getGetConsensusProposalsProposalIdVotesQueryOptions = <TData = Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConsensusProposalsProposalIdVotesQueryKey(proposalId,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>> = ({ signal }) => getConsensusProposalsProposalIdVotes(proposalId,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(proposalId), ...queryOptions}}

export type GetConsensusProposalsProposalIdVotesQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>>
export type GetConsensusProposalsProposalIdVotesQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of votes for a governance proposal.
 */
export const useGetConsensusProposalsProposalIdVotes = <TData = Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetConsensusProposalsProposalIdVotesQueryOptions(proposalId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of Emerald blocks.
 */
export const getRuntimeBlocks = (
    runtime: Runtime,
    params?: GetRuntimeBlocksParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeBlockList>> => {
    return axios.get(
      `/${runtime}/blocks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRuntimeBlocksQueryKey = (runtime: Runtime,
    params?: GetRuntimeBlocksParams,) => [`/${runtime}/blocks`, ...(params ? [params]: [])] as const;
  

    
export const getGetRuntimeBlocksQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeBlocks>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime,
    params?: GetRuntimeBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeBlocks>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeBlocks>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeBlocksQueryKey(runtime,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeBlocks>>> = ({ signal }) => getRuntimeBlocks(runtime,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime), ...queryOptions}}

export type GetRuntimeBlocksQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeBlocks>>>
export type GetRuntimeBlocksQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of Emerald blocks.
 */
export const useGetRuntimeBlocks = <TData = Awaited<ReturnType<typeof getRuntimeBlocks>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime,
    params?: GetRuntimeBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeBlocks>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeBlocksQueryOptions(runtime,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of Emerald transactions.
 */
export const getRuntimeTransactions = (
    runtime: Runtime,
    params?: GetRuntimeTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeTransactionList>> => {
    return axios.get(
      `/${runtime}/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRuntimeTransactionsQueryKey = (runtime: Runtime,
    params?: GetRuntimeTransactionsParams,) => [`/${runtime}/transactions`, ...(params ? [params]: [])] as const;
  

    
export const getGetRuntimeTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeTransactions>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime,
    params?: GetRuntimeTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeTransactions>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeTransactionsQueryKey(runtime,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeTransactions>>> = ({ signal }) => getRuntimeTransactions(runtime,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime), ...queryOptions}}

export type GetRuntimeTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeTransactions>>>
export type GetRuntimeTransactionsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of Emerald transactions.
 */
export const useGetRuntimeTransactions = <TData = Awaited<ReturnType<typeof getRuntimeTransactions>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime,
    params?: GetRuntimeTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeTransactions>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeTransactionsQueryOptions(runtime,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns runtime transactions with the given transaction hash.
 */
export const getRuntimeTransactionsTxHash = (
    runtime: Runtime,
    txHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeTransactionList>> => {
    return axios.get(
      `/${runtime}/transactions/${txHash}`,options
    );
  }


export const getGetRuntimeTransactionsTxHashQueryKey = (runtime: Runtime,
    txHash: string,) => [`/${runtime}/transactions/${txHash}`] as const;
  

    
export const getGetRuntimeTransactionsTxHashQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime,
    txHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeTransactionsTxHashQueryKey(runtime,txHash);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>> = ({ signal }) => getRuntimeTransactionsTxHash(runtime,txHash, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime && txHash), ...queryOptions}}

export type GetRuntimeTransactionsTxHashQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>>
export type GetRuntimeTransactionsTxHashQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns runtime transactions with the given transaction hash.
 */
export const useGetRuntimeTransactionsTxHash = <TData = Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime,
    txHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeTransactionsTxHash>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeTransactionsTxHashQueryOptions(runtime,txHash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of runtime events.
 */
export const getRuntimeEvents = (
    runtime: Runtime,
    params?: GetRuntimeEventsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeEventList>> => {
    return axios.get(
      `/${runtime}/events`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRuntimeEventsQueryKey = (runtime: Runtime,
    params?: GetRuntimeEventsParams,) => [`/${runtime}/events`, ...(params ? [params]: [])] as const;
  

    
export const getGetRuntimeEventsQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeEvents>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime,
    params?: GetRuntimeEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeEvents>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeEvents>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeEventsQueryKey(runtime,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeEvents>>> = ({ signal }) => getRuntimeEvents(runtime,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime), ...queryOptions}}

export type GetRuntimeEventsQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeEvents>>>
export type GetRuntimeEventsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of runtime events.
 */
export const useGetRuntimeEvents = <TData = Awaited<ReturnType<typeof getRuntimeEvents>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime,
    params?: GetRuntimeEventsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeEvents>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeEventsQueryOptions(runtime,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a list of EVM (ERC-20, ...) tokens on Emerald.
 */
export const getRuntimeEvmTokens = (
    runtime: Runtime,
    params?: GetRuntimeEvmTokensParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EvmTokenList>> => {
    return axios.get(
      `/${runtime}/evm_tokens`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRuntimeEvmTokensQueryKey = (runtime: Runtime,
    params?: GetRuntimeEvmTokensParams,) => [`/${runtime}/evm_tokens`, ...(params ? [params]: [])] as const;
  

    
export const getGetRuntimeEvmTokensQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeEvmTokens>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime,
    params?: GetRuntimeEvmTokensParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeEvmTokens>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeEvmTokens>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeEvmTokensQueryKey(runtime,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeEvmTokens>>> = ({ signal }) => getRuntimeEvmTokens(runtime,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime), ...queryOptions}}

export type GetRuntimeEvmTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeEvmTokens>>>
export type GetRuntimeEvmTokensQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a list of EVM (ERC-20, ...) tokens on Emerald.
 */
export const useGetRuntimeEvmTokens = <TData = Awaited<ReturnType<typeof getRuntimeEvmTokens>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime,
    params?: GetRuntimeEvmTokensParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeEvmTokens>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeEvmTokensQueryOptions(runtime,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a runtime account.
 */
export const getRuntimeAccountsAddress = (
    runtime: Runtime,
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeAccount>> => {
    return axios.get(
      `/${runtime}/accounts/${address}`,options
    );
  }


export const getGetRuntimeAccountsAddressQueryKey = (runtime: Runtime,
    address: string,) => [`/${runtime}/accounts/${address}`] as const;
  

    
export const getGetRuntimeAccountsAddressQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeAccountsAddress>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime,
    address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeAccountsAddress>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeAccountsAddress>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeAccountsAddressQueryKey(runtime,address);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeAccountsAddress>>> = ({ signal }) => getRuntimeAccountsAddress(runtime,address, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime && address), ...queryOptions}}

export type GetRuntimeAccountsAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeAccountsAddress>>>
export type GetRuntimeAccountsAddressQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a runtime account.
 */
export const useGetRuntimeAccountsAddress = <TData = Awaited<ReturnType<typeof getRuntimeAccountsAddress>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime,
    address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeAccountsAddress>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeAccountsAddressQueryOptions(runtime,address,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns the runtime status.
 */
export const getRuntimeStatus = (
    runtime: Runtime, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeStatus>> => {
    return axios.get(
      `/${runtime}/status`,options
    );
  }


export const getGetRuntimeStatusQueryKey = (runtime: Runtime,) => [`/${runtime}/status`] as const;
  

    
export const getGetRuntimeStatusQueryOptions = <TData = Awaited<ReturnType<typeof getRuntimeStatus>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(runtime: Runtime, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeStatus>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getRuntimeStatus>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRuntimeStatusQueryKey(runtime);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRuntimeStatus>>> = ({ signal }) => getRuntimeStatus(runtime, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(runtime), ...queryOptions}}

export type GetRuntimeStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getRuntimeStatus>>>
export type GetRuntimeStatusQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns the runtime status.
 */
export const useGetRuntimeStatus = <TData = Awaited<ReturnType<typeof getRuntimeStatus>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 runtime: Runtime, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRuntimeStatus>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRuntimeStatusQueryOptions(runtime,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a timeline of the transaction volume at the chosen granularity,
for either consensus or one of the paratimes.

 */
export const getLayerStatsTxVolume = (
    layer: Layer,
    params?: GetLayerStatsTxVolumeParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TxVolumeList>> => {
    return axios.get(
      `/${layer}/stats/tx_volume`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetLayerStatsTxVolumeQueryKey = (layer: Layer,
    params?: GetLayerStatsTxVolumeParams,) => [`/${layer}/stats/tx_volume`, ...(params ? [params]: [])] as const;
  

    
export const getGetLayerStatsTxVolumeQueryOptions = <TData = Awaited<ReturnType<typeof getLayerStatsTxVolume>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(layer: Layer,
    params?: GetLayerStatsTxVolumeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLayerStatsTxVolume>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getLayerStatsTxVolume>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLayerStatsTxVolumeQueryKey(layer,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLayerStatsTxVolume>>> = ({ signal }) => getLayerStatsTxVolume(layer,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(layer), ...queryOptions}}

export type GetLayerStatsTxVolumeQueryResult = NonNullable<Awaited<ReturnType<typeof getLayerStatsTxVolume>>>
export type GetLayerStatsTxVolumeQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a timeline of the transaction volume at the chosen granularity,
for either consensus or one of the paratimes.

 */
export const useGetLayerStatsTxVolume = <TData = Awaited<ReturnType<typeof getLayerStatsTxVolume>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 layer: Layer,
    params?: GetLayerStatsTxVolumeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLayerStatsTxVolume>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLayerStatsTxVolumeQueryOptions(layer,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Returns a (sliding) timeline of the recorded daily unique active accounts for
either consensus or one of the paratimes.

 */
export const getLayerStatsActiveAccounts = (
    layer: Layer,
    params?: GetLayerStatsActiveAccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ActiveAccountsList>> => {
    return axios.get(
      `/${layer}/stats/active_accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetLayerStatsActiveAccountsQueryKey = (layer: Layer,
    params?: GetLayerStatsActiveAccountsParams,) => [`/${layer}/stats/active_accounts`, ...(params ? [params]: [])] as const;
  

    
export const getGetLayerStatsActiveAccountsQueryOptions = <TData = Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(layer: Layer,
    params?: GetLayerStatsActiveAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>, TError, TData>, axios?: AxiosRequestConfig}
): UseQueryOptions<Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLayerStatsActiveAccountsQueryKey(layer,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>> = ({ signal }) => getLayerStatsActiveAccounts(layer,params, { signal, ...axiosOptions });
    
      
      
   return  { queryKey, queryFn, enabled: !!(layer), ...queryOptions}}

export type GetLayerStatsActiveAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>>
export type GetLayerStatsActiveAccountsQueryError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>

/**
 * @summary Returns a (sliding) timeline of the recorded daily unique active accounts for
either consensus or one of the paratimes.

 */
export const useGetLayerStatsActiveAccounts = <TData = Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>, TError = AxiosError<HumanReadableErrorResponse | NotFoundErrorResponse>>(
 layer: Layer,
    params?: GetLayerStatsActiveAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLayerStatsActiveAccounts>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetLayerStatsActiveAccountsQueryOptions(layer,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


