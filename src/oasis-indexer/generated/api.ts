/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * Oasis Indexer API V1
 * An API for accessing indexed data from the Oasis Network.
 * OpenAPI spec version: 0.1.0
 */
import axios from 'axios'
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  QueryFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
export type GetConsensusStatsDailyVolumeParams = { limit?: number; offset?: number };

export type GetConsensusStatsTpsParams = { limit?: number; offset?: number };

export type GetEmeraldTokensParams = { limit?: number; offset?: number };

export type GetEmeraldTransactionsParams = { limit?: number; offset?: number; block?: number };

export type GetEmeraldBlocksParams = { limit?: number; offset?: number; from?: number; to?: number; after?: string; before?: string };

export type GetConsensusProposalsProposalIdVotesParams = { limit?: number; offset?: number };

export type GetConsensusProposalsParams = { limit?: number; offset?: number; submitter?: string; state?: string };

export type GetConsensusEpochsParams = { limit?: number; offset?: number };

export type GetConsensusAccountsParams = { limit?: number; offset?: number; minAvailable?: number; maxAvailable?: number; minEscrow?: number; maxEscrow?: number; minDebonding?: number; maxDebonding?: number; minTotalBalance?: number; maxTotalBalance?: number };

export type GetConsensusValidatorsParams = { limit?: number; offset?: number };

export type GetConsensusEntitiesEntityIdNodesParams = { limit?: number; offset?: number };

export type GetConsensusEntitiesParams = { limit?: number; offset?: number };

export type GetConsensusTransactionsMethod = typeof GetConsensusTransactionsMethod[keyof typeof GetConsensusTransactionsMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetConsensusTransactionsMethod = {
  stakingTransfer: 'staking.Transfer',
  stakingAddEscrow: 'staking.AddEscrow',
  stakingReclaimEscrow: 'staking.ReclaimEscrow',
  stakingAmendCommissionSchedule: 'staking.AmendCommissionSchedule',
  stakingAllow: 'staking.Allow',
  stakingWithdraw: 'staking.Withdraw',
  roothashExecutorCommit: 'roothash.ExecutorCommit',
  roothashExecutorProposerTimeout: 'roothash.ExecutorProposerTimeout',
  registryRegisterEntity: 'registry.RegisterEntity',
  registryRegisterNode: 'registry.RegisterNode',
  registryRegisterRuntime: 'registry.RegisterRuntime',
  governanceCastVote: 'governance.CastVote',
  governanceSubmitProposal: 'governance.SubmitProposal',
  beaconPVSSCommit: 'beacon.PVSSCommit',
  beaconPVSSReveal: 'beacon.PVSSReveal',
  beaconVRFProve: 'beacon.VRFProve',
} as const;

export type GetConsensusTransactionsParams = { limit?: number; offset?: number; block?: number; method?: GetConsensusTransactionsMethod; sender?: string; minFee?: number; maxFee?: number; code?: number };

export type GetConsensusBlocksParams = { limit?: number; offset?: number; from?: number; to?: number; after?: string; before?: string };

/**
 * A server error occurred.
 */
export type ServerErrorResponse = ApiError;

/**
 * No results found.
 */
export type NotFoundResponse = ApiError;

/**
 * Invalid request.
 */
export type InvalidRequestResponse = ApiError;

export interface Volume {
  /** The date for this daily transaction volume measurement. */
  date?: string;
  /** The transaction volume on this day. */
  tx_volume?: number;
}

/**
 * A list of daily transaction volumes.

 */
export interface VolumeList {
  /** The list of daily transaction volumes. */
  volumes?: Volume[];
}

export interface TpsCheckpoint {
  /** The timestamp anchoring this TPS measurement window. */
  timestamp?: string;
  /** The transaction volume in this measurement window. */
  tx_volume?: number;
}

/**
 * A list of TPS checkpoint windows.

 */
export interface TpsCheckpoints {
  /** The length, in minutes, of each TPS measurement window. */
  interval_minutes?: number;
  /** The list of TPS checkpoint windows. */
  tps_checkpoints?: TpsCheckpoint[];
}

export interface RuntimeToken {
  /** The Oasis address of this token's contract. */
  token_addr?: string;
  /** The number of addresses that have a nonzero balance of this token,
as calculated from Transfer events.
 */
  num_holders?: number;
}

/**
 * A list of ERC-20 tokens on a runtime.

 */
export interface RuntimeTokenList {
  tokens?: RuntimeToken[];
}

/**
 * A runtime transaction.

 */
export interface RuntimeTransaction {
  /** The block round at which this transaction was executed. */
  round?: number;
  /** The Oasis cryptographic hash of this transaction's encoding. */
  hash?: string;
  /** The Ethereum cryptographic hash of this transaction's encoding.
Absent for non-Ethereum-format transactions.
 */
  eth_hash?: string;
  /** The Oasis address of this transaction's 0th signer. */
  sender_0?: string;
  /** The nonce used with this transaction's 0th signer, to prevent replay. */
  nonce_0?: number;
  /** The fee that this transaction's sender committed to pay to execute
it (total, native denomination, ParaTime base units, as a string).
 */
  fee_amount?: string;
  /** The maximum gas that this transaction's sender committed to use to
execute it.
 */
  fee_gas?: number;
  /** The method that was called. */
  method?: string;
  /** The method call body. */
  body?: string;
  /** A reasonable "to" Oasis address associated with this transaction,
if applicable. The meaning varies based on the transaction method.
 */
  to?: string;
  /** A reasonable "amount" associated with this transaction, if
applicable. The meaning varies based on the transaction mehtod.
Usually in native denomination, ParaTime units. As a string.
 */
  amount?: string;
  /** Whether this transaction successfully executed. */
  success?: boolean;
}

/**
 * A list of runtime transactions.

 */
export interface RuntimeTransactionList {
  transactions?: RuntimeTransaction[];
}

/**
 * A ParaTime block.

 */
export interface RuntimeBlock {
  /** The block round. */
  round?: number;
  /** The block header hash. */
  hash?: string;
  /** The second-granular consensus time. */
  timestamp?: string;
  /** The number of transactions in the block. */
  num_transactions?: number;
  /** The total byte size of all transactions in the block. */
  size?: number;
  /** The total gas used by all transactions in the block. */
  gas_used?: number;
}

/**
 * A list of consensus blocks.

 */
export interface RuntimeBlockList {
  blocks?: RuntimeBlock[];
}

export interface ProposalVote {
  /** The staking address casting this vote. */
  address?: string;
  /** The vote cast. */
  vote?: string;
}

/**
 * A list of votes for a governance proposal.

 */
export interface ProposalVotes {
  /** The unique identifier of the proposal. */
  proposal_id?: number;
  /** The list of votes for the proposal. */
  votes?: ProposalVote[];
}

/**
 * The target propotocol versions for this upgrade proposal.
 */
export type ProposalTarget = {
  consensus_protocol?: string;
  runtime_host_protocol?: string;
  runtime_committee_protocol?: string;
};

/**
 * A governance proposal.

 */
export interface Proposal {
  /** The unique identifier of the proposal. */
  id?: number;
  /** The staking address of the proposal submitter. */
  submitter?: string;
  /** The state of the proposal. */
  state?: string;
  /** The deposit attached to this proposal. */
  deposit?: number;
  /** The name of the upgrade handler. */
  handler?: string;
  /** The target propotocol versions for this upgrade proposal. */
  target?: ProposalTarget;
  /** The epoch at which the proposed upgrade will happen. */
  epoch?: number;
  /** The proposal to cancel, if this proposal proposes
cancelling an existing proposal. 
 */
  cancels?: number;
  /** The epoch at which this proposal was created. */
  created_at?: number;
  /** The epoch at which voting for this proposal will close. */
  closes_at?: number;
  /** The number of invalid votes for this proposal, after tallying.
 */
  invalid_votes?: number;
}

/**
 * A list of governance proposals.

 */
export interface ProposalList {
  proposals?: Proposal[];
}

/**
 * A consensus epoch.

 */
export interface Epoch {
  /** The epoch number. */
  id?: number;
  /** The (inclusive) height at which this epoch started. */
  start_height?: number;
  /** The (inclusive) height at which this epoch ended. */
  end_height?: number;
}

/**
 * A list of consensus epochs.

 */
export interface EpochList {
  epochs?: Epoch[];
}

export interface Allowance {
  /** The allowed account. */
  address?: string;
  /** The amount allowed for the allowed account. */
  amount?: number;
}

/**
 * A consensus layer account.

 */
export interface Account {
  /** The staking address for this account. */
  address?: string;
  /** A nonce used to prevent replay. */
  nonce?: number;
  /** The available balance, in base units. */
  available?: number;
  /** The active escrow balance, in base units. */
  escrow?: number;
  /** The debonding escrow balance, in base units. */
  debonding?: number;
  /** The delegations balance, in base units. */
  delegations_balance?: number;
  /** The debonding delegations balance, in base units. */
  debonding_delegations_balance?: number;
  /** The allowances made by this account. */
  allowances?: Allowance[];
}

/**
 * A list of consensus layer accounts.

 */
export interface AccountList {
  accounts?: Account[];
}

/**
 * A node registered at the consensus layer.

 */
export interface Node {
  /** The public key identifying this node. */
  id?: string;
  /** The public key identifying the entity controlling this node.
 */
  entity_id?: string;
  /** The epoch in which this node's commitment expires. */
  expiration?: number;
  /** The public key used for establishing TLS connections. */
  tls_pubkey?: string;
  /** The public key that will be used for establishing TLS connections
upon rotation.
 */
  tls_next_pubkey?: string;
  /** The unique identifier of this node on the P2P transport. */
  p2p_pubkey?: string;
  /** The unique identifier of this node as a consensus member */
  consensus_pubkey?: string;
  /** A bitmask representing this node's roles. */
  roles?: string;
}

/**
 * A list of nodes registered at the consensus layer.

 */
export interface NodeList {
  entity_id?: string;
  nodes?: Node[];
}

export type ValidatorCurrentCommissionBound = {
  lower?: number;
  upper?: number;
  epoch_start?: number;
  epoch_end?: number;
};

export type ValidatorMedia = {
  /** An URL associated with the entity. */
  website_link?: string;
  /** An email address for the validator. */
  email_address?: string;
  /** A Twitter handle. */
  twitter_acc?: string;
  /** An Telegram handle. */
  tg_chat?: string;
  /** A logo type. */
  logotype?: string;
};

/**
 * An validator registered at the consensus layer.

 */
export interface Validator {
  /** The staking address identifying this Validator. */
  entity_address?: string;
  /** The public key identifying this Validator. */
  entity_id?: string;
  /** The name of this Validator. */
  name?: string;
  /** The public key identifying this Validator's node. */
  node_id?: string;
  /** The amount staked. */
  escrow?: number;
  /** Entity is part of validator set. */
  active?: boolean;
  /** An entity has a node that is registered for being a validator, node is up to date, and has successfully registered itself. */
  status?: boolean;
  media?: ValidatorMedia;
  /** Commission rate. */
  current_rate?: number;
  current_commission_bound?: ValidatorCurrentCommissionBound;
}

/**
 * A list of validators registered at the consensus layer.

 */
export interface ValidatorList {
  validators?: Validator[];
}

/**
 * An entity registered at the consensus layer.

 */
export interface Entity {
  /** The public key identifying this entity. */
  id?: string;
  /** The vector of nodes owned by this entity. */
  nodes?: string[];
}

/**
 * A list of entities registered at the consensus layer.

 */
export interface EntityList {
  entities?: Entity[];
}

/**
 * The method that was called.
 */
export type TransactionMethod = typeof TransactionMethod[keyof typeof TransactionMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionMethod = {
  stakingTransfer: 'staking.Transfer',
  stakingAddEscrow: 'staking.AddEscrow',
  stakingReclaimEscrow: 'staking.ReclaimEscrow',
  stakingAmendCommissionSchedule: 'staking.AmendCommissionSchedule',
  stakingAllow: 'staking.Allow',
  stakingWithdraw: 'staking.Withdraw',
  roothashExecutorCommit: 'roothash.ExecutorCommit',
  roothashExecutorProposerTimeout: 'roothash.ExecutorProposerTimeout',
  registryRegisterEntity: 'registry.RegisterEntity',
  registryRegisterNode: 'registry.RegisterNode',
  registryRegisterRuntime: 'registry.RegisterRuntime',
  governanceCastVote: 'governance.CastVote',
  governanceSubmitProposal: 'governance.SubmitProposal',
  beaconPVSSCommit: 'beacon.PVSSCommit',
  beaconPVSSReveal: 'beacon.PVSSReveal',
  beaconVRFProve: 'beacon.VRFProve',
} as const;

/**
 * A consensus transaction.

 */
export interface Transaction {
  /** The block height at which this transaction was executed. */
  height?: number;
  /** The cryptographic hash of this transaction's encoding. */
  hash?: string;
  /** The nonce used with this transaction, to prevent replay. */
  nonce?: number;
  /** The fee that this transaction's sender committed
to pay to execute it.
 */
  fee?: number;
  /** The method that was called. */
  method?: TransactionMethod;
  /** The method call body. */
  body?: string;
  /** Whether this transaction successfully executed. */
  success?: boolean;
}

/**
 * A list of consensus transactions.

 */
export interface TransactionList {
  transactions?: Transaction[];
}

/**
 * A debonding delegation.

 */
export interface DebondingDelegation {
  /** The amount of tokens delegated in base units. */
  amount?: number;
  /** The shares of tokens delegated. */
  shares?: number;
  /** The delegatee address. */
  validator_address?: string;
  /** The epoch at which the debonding ends. */
  debond_end?: number;
}

/**
 * A list of debonding delegations.

 */
export interface DebondingDelegationList {
  transactions?: DebondingDelegation[];
}

/**
 * A delegation.

 */
export interface Delegation {
  /** The amount of tokens delegated in base units. */
  amount?: number;
  /** The shares of tokens delegated. */
  shares?: number;
  /** The delegatee address. */
  validator_address?: string;
}

/**
 * A list of delegations.

 */
export interface DelegationList {
  transactions?: Delegation[];
}

/**
 * A consensus block.

 */
export interface Block {
  /** The block height. */
  height?: number;
  /** The block header hash. */
  hash?: string;
  /** The second-granular consensus time. */
  timestamp?: string;
}

/**
 * A list of consensus blocks.

 */
export interface BlockList {
  blocks?: Block[];
}

export interface Status {
  /** The most recently indexed chain ID. */
  latest_chain_id?: string;
  /** The height of the most recent indexed block. Query a synced Oasis node for the latest block produced. */
  latest_block?: number;
  /** The RFC 3339 formatted time when the Indexer processed the latest block. Compare with current time for approximate indexing progress with the Oasis Network. */
  latest_update?: string;
}

export interface ApiError {
  /** An error message. */
  msg?: string;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


/**
 * @summary Returns the indexer status.
 */
export const get = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Status>> => {
    return axios.get(
      `/`,options
    );
  }


export const getGetQueryKey = () => [`/`];

    
export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = AxiosError<ApiError>

export const useGet = <TData = Awaited<ReturnType<typeof get>>, TError = AxiosError<ApiError>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey();

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get({ signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof get>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of consensus blocks, sorted from most to least recent.
 */
export const getConsensusBlocks = (
    params?: GetConsensusBlocksParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BlockList>> => {
    return axios.get(
      `/consensus/blocks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusBlocksQueryKey = (params?: GetConsensusBlocksParams,) => [`/consensus/blocks`, ...(params ? [params]: [])];

    
export type GetConsensusBlocksQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusBlocks>>>
export type GetConsensusBlocksQueryError = AxiosError<ApiError>

export const useGetConsensusBlocks = <TData = Awaited<ReturnType<typeof getConsensusBlocks>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocks>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusBlocksQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusBlocks>>> = ({ signal }) => getConsensusBlocks(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusBlocks>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a consensus block.
 */
export const getConsensusBlocksHeight = (
    height: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Block>> => {
    return axios.get(
      `/consensus/blocks/${height}`,options
    );
  }


export const getGetConsensusBlocksHeightQueryKey = (height: number,) => [`/consensus/blocks/${height}`];

    
export type GetConsensusBlocksHeightQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusBlocksHeight>>>
export type GetConsensusBlocksHeightQueryError = AxiosError<ApiError>

export const useGetConsensusBlocksHeight = <TData = Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError = AxiosError<ApiError>>(
 height: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusBlocksHeightQueryKey(height);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusBlocksHeight>>> = ({ signal }) => getConsensusBlocksHeight(height, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusBlocksHeight>>, TError, TData>(queryKey, queryFn, {enabled: !!(height), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of consensus transactions.
 */
export const getConsensusTransactions = (
    params?: GetConsensusTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionList>> => {
    return axios.get(
      `/consensus/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusTransactionsQueryKey = (params?: GetConsensusTransactionsParams,) => [`/consensus/transactions`, ...(params ? [params]: [])];

    
export type GetConsensusTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusTransactions>>>
export type GetConsensusTransactionsQueryError = AxiosError<ApiError>

export const useGetConsensusTransactions = <TData = Awaited<ReturnType<typeof getConsensusTransactions>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactions>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusTransactionsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusTransactions>>> = ({ signal }) => getConsensusTransactions(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusTransactions>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a consensus transaction.
 */
export const getConsensusTransactionsTxHash = (
    txHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Transaction>> => {
    return axios.get(
      `/consensus/transactions/${txHash}`,options
    );
  }


export const getGetConsensusTransactionsTxHashQueryKey = (txHash: string,) => [`/consensus/transactions/${txHash}`];

    
export type GetConsensusTransactionsTxHashQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>>
export type GetConsensusTransactionsTxHashQueryError = AxiosError<ApiError>

export const useGetConsensusTransactionsTxHash = <TData = Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError = AxiosError<ApiError>>(
 txHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusTransactionsTxHashQueryKey(txHash);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>> = ({ signal }) => getConsensusTransactionsTxHash(txHash, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusTransactionsTxHash>>, TError, TData>(queryKey, queryFn, {enabled: !!(txHash), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of entities registered at the consensus layer.
 */
export const getConsensusEntities = (
    params?: GetConsensusEntitiesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EntityList>> => {
    return axios.get(
      `/consensus/entities`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEntitiesQueryKey = (params?: GetConsensusEntitiesParams,) => [`/consensus/entities`, ...(params ? [params]: [])];

    
export type GetConsensusEntitiesQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntities>>>
export type GetConsensusEntitiesQueryError = AxiosError<ApiError>

export const useGetConsensusEntities = <TData = Awaited<ReturnType<typeof getConsensusEntities>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusEntitiesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntities>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusEntitiesQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntities>>> = ({ signal }) => getConsensusEntities(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusEntities>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns an entity registered at the consensus layer.
 */
export const getConsensusEntitiesEntityId = (
    entityId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Entity>> => {
    return axios.get(
      `/consensus/entities/${entityId}`,options
    );
  }


export const getGetConsensusEntitiesEntityIdQueryKey = (entityId: string,) => [`/consensus/entities/${entityId}`];

    
export type GetConsensusEntitiesEntityIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>>
export type GetConsensusEntitiesEntityIdQueryError = AxiosError<ApiError>

export const useGetConsensusEntitiesEntityId = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError = AxiosError<ApiError>>(
 entityId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusEntitiesEntityIdQueryKey(entityId);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>> = ({ signal }) => getConsensusEntitiesEntityId(entityId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusEntitiesEntityId>>, TError, TData>(queryKey, queryFn, {enabled: !!(entityId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of nodes registered at the consensus layer.
 */
export const getConsensusEntitiesEntityIdNodes = (
    entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NodeList>> => {
    return axios.get(
      `/consensus/entities/${entityId}/nodes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEntitiesEntityIdNodesQueryKey = (entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams,) => [`/consensus/entities/${entityId}/nodes`, ...(params ? [params]: [])];

    
export type GetConsensusEntitiesEntityIdNodesQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>>
export type GetConsensusEntitiesEntityIdNodesQueryError = AxiosError<ApiError>

export const useGetConsensusEntitiesEntityIdNodes = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError = AxiosError<ApiError>>(
 entityId: string,
    params?: GetConsensusEntitiesEntityIdNodesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusEntitiesEntityIdNodesQueryKey(entityId,params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>> = ({ signal }) => getConsensusEntitiesEntityIdNodes(entityId,params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodes>>, TError, TData>(queryKey, queryFn, {enabled: !!(entityId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a node registered at the consensus layer.
 */
export const getConsensusEntitiesEntityIdNodesNodeId = (
    entityId: string,
    nodeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Node>> => {
    return axios.get(
      `/consensus/entities/${entityId}/nodes/${nodeId}`,options
    );
  }


export const getGetConsensusEntitiesEntityIdNodesNodeIdQueryKey = (entityId: string,
    nodeId: string,) => [`/consensus/entities/${entityId}/nodes/${nodeId}`];

    
export type GetConsensusEntitiesEntityIdNodesNodeIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>>
export type GetConsensusEntitiesEntityIdNodesNodeIdQueryError = AxiosError<ApiError>

export const useGetConsensusEntitiesEntityIdNodesNodeId = <TData = Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError = AxiosError<ApiError>>(
 entityId: string,
    nodeId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusEntitiesEntityIdNodesNodeIdQueryKey(entityId,nodeId);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>> = ({ signal }) => getConsensusEntitiesEntityIdNodesNodeId(entityId,nodeId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusEntitiesEntityIdNodesNodeId>>, TError, TData>(queryKey, queryFn, {enabled: !!(entityId && nodeId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of validators registered at the consensus layer.
 */
export const getConsensusValidators = (
    params?: GetConsensusValidatorsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ValidatorList>> => {
    return axios.get(
      `/consensus/validators`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusValidatorsQueryKey = (params?: GetConsensusValidatorsParams,) => [`/consensus/validators`, ...(params ? [params]: [])];

    
export type GetConsensusValidatorsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusValidators>>>
export type GetConsensusValidatorsQueryError = AxiosError<ApiError>

export const useGetConsensusValidators = <TData = Awaited<ReturnType<typeof getConsensusValidators>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusValidatorsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidators>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusValidatorsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusValidators>>> = ({ signal }) => getConsensusValidators(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusValidators>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a validator registered at the consensus layer.
 */
export const getConsensusValidatorsEntityId = (
    entityId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Validator>> => {
    return axios.get(
      `/consensus/validators/${entityId}`,options
    );
  }


export const getGetConsensusValidatorsEntityIdQueryKey = (entityId: string,) => [`/consensus/validators/${entityId}`];

    
export type GetConsensusValidatorsEntityIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>>
export type GetConsensusValidatorsEntityIdQueryError = AxiosError<ApiError>

export const useGetConsensusValidatorsEntityId = <TData = Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError = AxiosError<ApiError>>(
 entityId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusValidatorsEntityIdQueryKey(entityId);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>> = ({ signal }) => getConsensusValidatorsEntityId(entityId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusValidatorsEntityId>>, TError, TData>(queryKey, queryFn, {enabled: !!(entityId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of consensus layer accounts.
 */
export const getConsensusAccounts = (
    params?: GetConsensusAccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountList>> => {
    return axios.get(
      `/consensus/accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusAccountsQueryKey = (params?: GetConsensusAccountsParams,) => [`/consensus/accounts`, ...(params ? [params]: [])];

    
export type GetConsensusAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccounts>>>
export type GetConsensusAccountsQueryError = AxiosError<ApiError>

export const useGetConsensusAccounts = <TData = Awaited<ReturnType<typeof getConsensusAccounts>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccounts>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusAccountsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccounts>>> = ({ signal }) => getConsensusAccounts(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusAccounts>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a consensus layer account.
 */
export const getConsensusAccountsAddress = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Account>> => {
    return axios.get(
      `/consensus/accounts/${address}`,options
    );
  }


export const getGetConsensusAccountsAddressQueryKey = (address: string,) => [`/consensus/accounts/${address}`];

    
export type GetConsensusAccountsAddressQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddress>>>
export type GetConsensusAccountsAddressQueryError = AxiosError<ApiError>

export const useGetConsensusAccountsAddress = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError = AxiosError<ApiError>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusAccountsAddressQueryKey(address);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddress>>> = ({ signal }) => getConsensusAccountsAddress(address, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusAccountsAddress>>, TError, TData>(queryKey, queryFn, {enabled: !!(address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns an account's delegations.
 */
export const getConsensusAccountsAddressDelegations = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DelegationList>> => {
    return axios.get(
      `/consensus/accounts/${address}/delegations`,options
    );
  }


export const getGetConsensusAccountsAddressDelegationsQueryKey = (address: string,) => [`/consensus/accounts/${address}/delegations`];

    
export type GetConsensusAccountsAddressDelegationsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>>
export type GetConsensusAccountsAddressDelegationsQueryError = AxiosError<ApiError>

export const useGetConsensusAccountsAddressDelegations = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError = AxiosError<ApiError>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusAccountsAddressDelegationsQueryKey(address);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>> = ({ signal }) => getConsensusAccountsAddressDelegations(address, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusAccountsAddressDelegations>>, TError, TData>(queryKey, queryFn, {enabled: !!(address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns an account's debonding delegations.
 */
export const getConsensusAccountsAddressDebondingDelegations = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DebondingDelegationList>> => {
    return axios.get(
      `/consensus/accounts/${address}/debonding_delegations`,options
    );
  }


export const getGetConsensusAccountsAddressDebondingDelegationsQueryKey = (address: string,) => [`/consensus/accounts/${address}/debonding_delegations`];

    
export type GetConsensusAccountsAddressDebondingDelegationsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>>
export type GetConsensusAccountsAddressDebondingDelegationsQueryError = AxiosError<ApiError>

export const useGetConsensusAccountsAddressDebondingDelegations = <TData = Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError = AxiosError<ApiError>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusAccountsAddressDebondingDelegationsQueryKey(address);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>> = ({ signal }) => getConsensusAccountsAddressDebondingDelegations(address, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusAccountsAddressDebondingDelegations>>, TError, TData>(queryKey, queryFn, {enabled: !!(address), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of consensus epochs.
 */
export const getConsensusEpochs = (
    params?: GetConsensusEpochsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EpochList>> => {
    return axios.get(
      `/consensus/epochs`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusEpochsQueryKey = (params?: GetConsensusEpochsParams,) => [`/consensus/epochs`, ...(params ? [params]: [])];

    
export type GetConsensusEpochsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEpochs>>>
export type GetConsensusEpochsQueryError = AxiosError<ApiError>

export const useGetConsensusEpochs = <TData = Awaited<ReturnType<typeof getConsensusEpochs>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusEpochsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochs>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusEpochsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEpochs>>> = ({ signal }) => getConsensusEpochs(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusEpochs>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a consensus epoch.
 */
export const getConsensusEpochsEpoch = (
    epoch: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Epoch>> => {
    return axios.get(
      `/consensus/epochs/${epoch}`,options
    );
  }


export const getGetConsensusEpochsEpochQueryKey = (epoch: number,) => [`/consensus/epochs/${epoch}`];

    
export type GetConsensusEpochsEpochQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>>
export type GetConsensusEpochsEpochQueryError = AxiosError<ApiError>

export const useGetConsensusEpochsEpoch = <TData = Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError = AxiosError<ApiError>>(
 epoch: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusEpochsEpochQueryKey(epoch);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>> = ({ signal }) => getConsensusEpochsEpoch(epoch, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusEpochsEpoch>>, TError, TData>(queryKey, queryFn, {enabled: !!(epoch), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of governance proposals.
 */
export const getConsensusProposals = (
    params?: GetConsensusProposalsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProposalList>> => {
    return axios.get(
      `/consensus/proposals`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusProposalsQueryKey = (params?: GetConsensusProposalsParams,) => [`/consensus/proposals`, ...(params ? [params]: [])];

    
export type GetConsensusProposalsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusProposals>>>
export type GetConsensusProposalsQueryError = AxiosError<ApiError>

export const useGetConsensusProposals = <TData = Awaited<ReturnType<typeof getConsensusProposals>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusProposalsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposals>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusProposalsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusProposals>>> = ({ signal }) => getConsensusProposals(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusProposals>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a governance proposal.
 */
export const getConsensusProposalsProposalId = (
    proposalId: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Proposal>> => {
    return axios.get(
      `/consensus/proposals/${proposalId}`,options
    );
  }


export const getGetConsensusProposalsProposalIdQueryKey = (proposalId: number,) => [`/consensus/proposals/${proposalId}`];

    
export type GetConsensusProposalsProposalIdQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>>
export type GetConsensusProposalsProposalIdQueryError = AxiosError<ApiError>

export const useGetConsensusProposalsProposalId = <TData = Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError = AxiosError<ApiError>>(
 proposalId: number, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusProposalsProposalIdQueryKey(proposalId);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>> = ({ signal }) => getConsensusProposalsProposalId(proposalId, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusProposalsProposalId>>, TError, TData>(queryKey, queryFn, {enabled: !!(proposalId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of votes for a governance proposal.
 */
export const getConsensusProposalsProposalIdVotes = (
    proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProposalVotes>> => {
    return axios.get(
      `/consensus/proposals/${proposalId}/votes`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusProposalsProposalIdVotesQueryKey = (proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams,) => [`/consensus/proposals/${proposalId}/votes`, ...(params ? [params]: [])];

    
export type GetConsensusProposalsProposalIdVotesQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>>
export type GetConsensusProposalsProposalIdVotesQueryError = AxiosError<ApiError>

export const useGetConsensusProposalsProposalIdVotes = <TData = Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError = AxiosError<ApiError>>(
 proposalId: number,
    params?: GetConsensusProposalsProposalIdVotesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusProposalsProposalIdVotesQueryKey(proposalId,params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>> = ({ signal }) => getConsensusProposalsProposalIdVotes(proposalId,params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusProposalsProposalIdVotes>>, TError, TData>(queryKey, queryFn, {enabled: !!(proposalId), ...queryOptions}) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of Emerald blocks.
 */
export const getEmeraldBlocks = (
    params?: GetEmeraldBlocksParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeBlockList>> => {
    return axios.get(
      `/emerald/blocks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetEmeraldBlocksQueryKey = (params?: GetEmeraldBlocksParams,) => [`/emerald/blocks`, ...(params ? [params]: [])];

    
export type GetEmeraldBlocksQueryResult = NonNullable<Awaited<ReturnType<typeof getEmeraldBlocks>>>
export type GetEmeraldBlocksQueryError = AxiosError<ApiError>

export const useGetEmeraldBlocks = <TData = Awaited<ReturnType<typeof getEmeraldBlocks>>, TError = AxiosError<ApiError>>(
 params?: GetEmeraldBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEmeraldBlocks>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEmeraldBlocksQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmeraldBlocks>>> = ({ signal }) => getEmeraldBlocks(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getEmeraldBlocks>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of Emerald transactions.
 */
export const getEmeraldTransactions = (
    params?: GetEmeraldTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeTransactionList>> => {
    return axios.get(
      `/emerald/transactions`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetEmeraldTransactionsQueryKey = (params?: GetEmeraldTransactionsParams,) => [`/emerald/transactions`, ...(params ? [params]: [])];

    
export type GetEmeraldTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof getEmeraldTransactions>>>
export type GetEmeraldTransactionsQueryError = AxiosError<ApiError>

export const useGetEmeraldTransactions = <TData = Awaited<ReturnType<typeof getEmeraldTransactions>>, TError = AxiosError<ApiError>>(
 params?: GetEmeraldTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEmeraldTransactions>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEmeraldTransactionsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmeraldTransactions>>> = ({ signal }) => getEmeraldTransactions(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getEmeraldTransactions>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns a list of ERC-20 tokens on Emerald.
 */
export const getEmeraldTokens = (
    params?: GetEmeraldTokensParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RuntimeTokenList>> => {
    return axios.get(
      `/emerald/tokens`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetEmeraldTokensQueryKey = (params?: GetEmeraldTokensParams,) => [`/emerald/tokens`, ...(params ? [params]: [])];

    
export type GetEmeraldTokensQueryResult = NonNullable<Awaited<ReturnType<typeof getEmeraldTokens>>>
export type GetEmeraldTokensQueryError = AxiosError<ApiError>

export const useGetEmeraldTokens = <TData = Awaited<ReturnType<typeof getEmeraldTokens>>, TError = AxiosError<ApiError>>(
 params?: GetEmeraldTokensParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEmeraldTokens>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetEmeraldTokensQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmeraldTokens>>> = ({ signal }) => getEmeraldTokens(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getEmeraldTokens>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns the consensus layer TPS for each 5 minute interval.
 */
export const getConsensusStatsTps = (
    params?: GetConsensusStatsTpsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TpsCheckpoints>> => {
    return axios.get(
      `/consensus/stats/tps`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusStatsTpsQueryKey = (params?: GetConsensusStatsTpsParams,) => [`/consensus/stats/tps`, ...(params ? [params]: [])];

    
export type GetConsensusStatsTpsQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusStatsTps>>>
export type GetConsensusStatsTpsQueryError = AxiosError<ApiError>

export const useGetConsensusStatsTps = <TData = Awaited<ReturnType<typeof getConsensusStatsTps>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusStatsTpsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusStatsTps>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusStatsTpsQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusStatsTps>>> = ({ signal }) => getConsensusStatsTps(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusStatsTps>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


/**
 * @summary Returns the consensus layer daily transaction volume for each day.
 */
export const getConsensusStatsDailyVolume = (
    params?: GetConsensusStatsDailyVolumeParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<VolumeList>> => {
    return axios.get(
      `/consensus/stats/daily_volume`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetConsensusStatsDailyVolumeQueryKey = (params?: GetConsensusStatsDailyVolumeParams,) => [`/consensus/stats/daily_volume`, ...(params ? [params]: [])];

    
export type GetConsensusStatsDailyVolumeQueryResult = NonNullable<Awaited<ReturnType<typeof getConsensusStatsDailyVolume>>>
export type GetConsensusStatsDailyVolumeQueryError = AxiosError<ApiError>

export const useGetConsensusStatsDailyVolume = <TData = Awaited<ReturnType<typeof getConsensusStatsDailyVolume>>, TError = AxiosError<ApiError>>(
 params?: GetConsensusStatsDailyVolumeParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConsensusStatsDailyVolume>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConsensusStatsDailyVolumeQueryKey(params);

  

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConsensusStatsDailyVolume>>> = ({ signal }) => getConsensusStatsDailyVolume(params, { signal, ...axiosOptions });

  const query = useQuery<Awaited<ReturnType<typeof getConsensusStatsDailyVolume>>, TError, TData>(queryKey, queryFn, queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
}


